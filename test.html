<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<title>Oscillation Simulator ‚Äî Improved</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  /* Giao di·ªán */
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    background: linear-gradient(135deg, #6EE7B7, #3B82F6);
    color: #fff;
  }
  #main { flex:1; padding:12px; display:flex; flex-direction:column; gap:8px; box-sizing:border-box; }
  canvas { 
      width: 100%;
      height: 300px;
      background:#fff; 
      border-radius:10px; 
      border:2px solid #000; 
      display:block; }
  .eqn { margin-top:12px; background: rgba(255,255,255,0.12); padding:8px; border-radius:8px; color:#fff; font-weight:600; }
  .small { font-size:13px; color: #f3f3f3; opacity:0.95; }
  #sidebar {
  flex: 0 0 auto;
  width: 100%;
  max-height: 40vh;
  background: rgba(0,0,0,0.25);
  backdrop-filter: blur(10px);
  padding: 12px 16px;
  overflow-y: auto;
  box-sizing: border-box;
  font-size: 14px;
  display: grid;
  grid-template-columns: 1fr 1fr;   /* 2 c·ªôt */
  column-gap: 16px;
}
/* ti√™u ƒë·ªÅ chi·∫øm full h√†ng */
#sidebar h2,
#sidebar .btns,
#sidebar .eqn,
#sidebar .small {
  grid-column: 1 / -1;
  text-align: center;
}
/* m·ªói th√¥ng s·ªë */
.param {
  display: grid;
  grid-template-columns: auto 1fr 70px;
  align-items: center;
  gap: 6px;
  margin-top: 6px;
}
/* label */
.param label {
  font-weight: bold;
  white-space: nowrap;
  font-size: 13px;
}
/* slider */
.param input[type=range] {
  width: 100%;
  height: 18px;
}
/* √¥ s·ªë */
.param input[type=number] {
  width: 60px;
  text-align: right;
  padding: 4px;
  border-radius: 8px;
  border: none;
  font-size: 13px;
}
/* select */
.param select {
  grid-column: 2 / 4;
  padding: 6px;
  border-radius: 8px;
  border: none;
}
/* n√∫t */
.btns {
  margin-top: 14px;
  display: flex;
  gap: 6px;
}
button {
  flex: 1;
  padding: 10px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  font-weight: 700;
  background: #ffd54f;
  color: #000;
}
</style>
</head>
<body>

<div id="main">
  <canvas id="canvas" height="520"></canvas>
</div>

<div id="sidebar" >


  <div class="param">
  <label>Bi√™n ƒë·ªô A (cm)</label>
  <input id="A_slider" type="range" min="0" max="10" step="0.1" value="5">
  <input id="A_num" type="number" min="0" max="10" step="0.1" value="5">
</div>

<div class="param">
  <label>œâ (rad/s)</label>
  <input id="w_slider" type="range" min="0.5" max="20" step="0.1" value="6.28">
  <input id="w_num" type="number" min="0.5" max="20" step="0.1" value="6.28">
</div>

<div class="param">
  <label>œÜ (rad)</label>
  <input id="phi_slider" type="range" min="-3.14" max="3.14" step="0.01" value="0">
  <input id="phi_num" type="number" min="-3.14" max="3.14" step="0.01" value="0">
</div>

<div class="param">
  <label>H√†m</label>
  <select id="func">
    <option value="cos">cos</option>
    <option value="sin">sin</option>
  </select>
</div>

  <div class="btns">
    <button id="toggleBtn">‚ñ∂ Ch·∫°y</button>
    <button id="resetBtn">üîÑ Kh√¥i ph·ª•c</button>
  </div>

  <div class="eqn" id="equation">x(t) = 5.00 cm . cos(6.28 t + 0.00)</div>
  <div class="small">Ph∆∞∆°ng tr√¨nh c·∫≠p nh·∫≠t theo tham s·ªë. ƒê∆°n v·ªã x: cm.</div>
</div>

<script>
// Thi·∫øt l·∫≠p tham chi·∫øu ƒë·∫øn c√°c ph·∫ßn t·ª≠ DOM (kh·∫Øc ph·ª•c l·ªìi li√™n k·∫øt)
const A_slider = document.getElementById('A_slider');
const A_num = document.getElementById('A_num');
const w_slider = document.getElementById('w_slider');
const w_num = document.getElementById('w_num');
const phi_slider = document.getElementById('phi_slider');
const phi_num = document.getElementById('phi_num');
const func = document.getElementById('func');

const toggleBtn = document.getElementById('toggleBtn');
const resetBtn = document.getElementById('resetBtn');
const equationDiv = document.getElementById('equation');

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Tr·∫°ng th√°i
let A_cm = parseFloat(A_num.value);
let omega = parseFloat(w_num.value);
let phi = parseFloat(phi_num.value);
let mode = func.value;

let t = 0;
let dt = 0.02;
let running = false;
let paused = false;
let history = [];
let t_offset = 0; //slide for timeline

// H√†m h·ªó tr·ª£ chuy·ªÉn ƒë·ªïi ƒë∆°n v·ªã
function cmToM(cm){ return cm/100; }
function mToCm(m){ return m*100; }

// Li√™n k·∫øt d·ªØ li·ªáu gi·ªØa slider v√† √¥ nh·∫≠p m·ªôt c√°ch ·ªïn ƒë·ªãnh
function bind(sliderEl, numEl, onChange) {
  sliderEl.addEventListener('input', () => { numEl.value = sliderEl.value; onChange(); });
  numEl.addEventListener('input', () => {
    // √âp gi√° tr·ªã v√†o trong kho·∫£ng min/max gi·ªëng nh∆∞ slider
    if(numEl.value==='') return;
    let v = parseFloat(numEl.value);
    if(v<parseFloat(sliderEl.min)) v=parseFloat(sliderEl.min);
    if(v>parseFloat(sliderEl.max)) v=parseFloat(sliderEl.max);
    sliderEl.value = v;
    onChange();
  });
}

bind(A_slider,A_num,()=>{ A_cm = parseFloat(A_num.value); updateEquation(); });
bind(w_slider,w_num,()=>{ omega = parseFloat(w_num.value); updateEquation(); });
bind(phi_slider,phi_num,()=>{ phi = parseFloat(phi_num.value); updateEquation(); });
func.addEventListener('change', ()=>{ mode = func.value; updateEquation(); });

// Hi·ªÉn th·ªã ph∆∞∆°ng tr√¨nh
function updateEquation(){
  const Ashow = Number(A_cm).toFixed(2).replace(".",",");
  const wshow = Number(omega).toFixed(2).replace(".",",");
  const phishow = Math.abs(phi).toFixed(2).replace(".",",");
  const fun = (mode==='cos')?'cos':'sin';
  
  let phiStr = '';
  if (phi >= 0) {
    phiStr = ` + ${phishow}`;
  } else if (phi < 0) {
    phiStr = ` ‚àí ${phishow}`;
    }

equationDiv.textContent = `x(t) = ${Ashow} . ${fun}(${wshow} t${phiStr}) (cm)`;
}

// Kh·ªüi t·∫°o
updateEquation();

//T√≠nh x(t) v√† tr·∫£ v·ªÅ ƒë∆°n v·ªã m
function computeX(tval){
  const A_m = cmToM(A_cm);
  const arg = omega * tval + phi;
  return (mode==='cos')? A_m*Math.cos(arg): A_m*Math.sin(arg);
}

//V·∫Ω m√¥ ph·ªèng (l√≤ xo v√† v·∫≠t n·∫∑ng)
function drawSimulation(x_m){
  // x_m t√≠nh b·∫±ng m, chuy·ªÉn sang px ƒë·ªÉ hi·ªÉn th·ªã, cƒÉn gi·ªØa theo chi·ªÅu ngang
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  const scale = (canvas.height-80)/24*100; //px tr√™n m, cho gi·∫£ l·∫≠p h√¨nh ·∫£nh, d√πng ƒë·ªÉ tƒÉng gi·∫£m ƒë·ªô d√†i

  // ƒêi·ªÉm c·ªë ƒë·ªãnh c·ªßa l√≤ xo
  const anchorX = centerX;
  const anchorY = 30;
  
  // V·∫Ω t∆∞·ªùng c·ªë ƒë·ªãnh
  ctx.fillStyle='#444';
  ctx.fillRect(anchorX-40,anchorY,80,10);

  // L√≤ xo: v·∫Ω d·∫°ng rƒÉng c∆∞a t·ª´ ƒëi·ªÉm c·ªë ƒë·ªãnh ƒë·∫øn t√¢m v·∫≠t n·∫∑ng
  const massX = centerX;
  const massY = centerY + x_m*scale;
  const springEndY = massY - 15; //ƒêi·ªÉm g·∫Øn v√†o v·∫≠t n·∫∑ng

  //V·∫Ω ƒë∆∞·ªùng l√≤ xo
  ctx.strokeStyle='#222';
  ctx.lineWidth=3;
  ctx.beginPath();
  const coils=5;
  const totalLen = Math.max(30, springEndY - anchorY -15);
  const step = totalLen/(coils*2);
  let px=anchorX, py=anchorY;
  ctx.moveTo(px, py+10);
  for(let i=0;i<coils*2;i++){
    py += step;
    px = anchorX + (i%2===0?-10:10); //tƒÉng m·ª©c ƒë·ªô gi√£n cho l√≤ xo
    ctx.lineTo(px, py+10);
  }
  ctx.lineTo(anchorX, springEndY);
  ctx.stroke();

  //Th√¥ng s·ªë v·∫≠t n·∫∑ng
  const wRect =36, hRect=28;
  const rectX = massX - wRect/2;
  const rectY = massY - hRect/2;
  //ƒê·ªï b√≥ng
  ctx.fillStyle='rgba(0,0,0,0.12)';
  ctx.fillRect(rectX+6, rectY+10, wRect,6);
  //Kh·ªëi ch√≠nh c·ªßa v·∫≠t n·∫∑ng
  ctx.fillStyle='#ff3b7f';
  ctx.fillRect(rectX, rectY, wRect, hRect);
  ctx.strokeStyle='#b3164f';
  ctx.lineWidth=2;
  ctx.strokeRect(rectX, rectY, wRect, hRect);
  //V·ªát s√°ng nh·ªè
  ctx.fillStyle='rgba(255,255,255,0.6)';
  ctx.fillRect(rectX+4, rectY+4, Math.max(4,wRect/3),6);
}

// V·∫Ω ƒë·ªì th·ªã
function drawGraph(){

  //B·ªë c·ª•c v√† t·ªâ l·ªá
  const originXhorizontal = 20;//l·ªÅ tr√°i tr·ª•c ngang
  const originXvertical = canvas.width/2;//l·ªÅ tr√°i tr·ª•c d·ªçc
  const originY = canvas.height/2;//cƒÉn gi·ªØa theo chi·ªÅu d·ªçc
  const pxPerSec = 80; //t·ªâ l·ªá ngang (px tr√™n s)
  const pxPerCm = (canvas.height-80)/24; //t·ªâ l·ªá d·ªçc (px tr√™n cm)

  //V·∫Ω l∆∞·ªõi m·ªù
  ctx.strokeStyle='#e6e6e6';
  ctx.lineWidth=0.6;
  for(let gx=0;gx<canvas.width;gx+=50){ctx.beginPath();ctx.moveTo(gx,0);ctx.lineTo(gx,canvas.height/2);ctx.stroke();}
  for(let gy=0;gy<canvas.height/2;gy+=54){ctx.beginPath();ctx.moveTo(0,gy);ctx.lineTo(canvas.width,gy);ctx.stroke();}

  //Tr·ª•c to·∫°n ƒë·ªô
  ctx.strokeStyle='#000';
  ctx.lineWidth=2;
  //Tr·ª•c ƒë·ª©ng
  ctx.beginPath(); ctx.moveTo(originXvertical,10); ctx.lineTo(originXvertical,canvas.height-10); ctx.stroke();
  //Tr·ª•c ngang
  ctx.beginPath(); ctx.moveTo(originXhorizontal,originY); ctx.lineTo(canvas.width-20,originY); ctx.stroke();

  //M≈©i t√™n tr·ª•c
  ctx.fillStyle='#000';
  //d·ªçc
  ctx.beginPath(); ctx.moveTo(originXvertical,10); ctx.lineTo(originXvertical-6,22); ctx.lineTo(originXvertical+6,22); ctx.closePath(); ctx.fill();
  //ngang
  ctx.beginPath(); ctx.moveTo(canvas.width-10,originY); ctx.lineTo(canvas.width-20,originY-6); ctx.lineTo(canvas.width-20,originY+6); ctx.closePath(); ctx.fill();
  
  //V·∫°ch chia tr√™n tr·ª•c th·ªùi gian
  ctx.fillStyle='#000';
  ctx.font='13px Arial';
  const tickSec=0.5, marginRight=20;
  const totalVisibleTime = (canvas.width-originXhorizontal-marginRight)/pxPerSec; //T√≠nh s·ªë tick c·∫ßn hi·ªÉn th·ªã d·ª±a tr√™n ƒë·ªô r·ªông canvas
  if(typeof window.initializedOffset==="undefined"){ t_offset=-totalVisibleTime/2; window.initializedOffset=true; }
  const firstTick = Math.floor(t_offset/tickSec);
  const lastTick = Math.ceil((t_offset+totalVisibleTime-0.5)/tickSec);

  for(let i=firstTick;i<=lastTick;i++){
    const tLabel=i*tickSec;
    const tx = originXhorizontal+(tLabel-t_offset)*pxPerSec;
    if(tLabel<0 || tx<originXhorizontal) continue; //ch·ªâ v·∫Ω tr√™n canvas
    //v·∫Ω tick nh·ªè
    ctx.beginPath(); ctx.moveTo(tx, originY-6); ctx.lineTo(tx, originY+6); ctx.stroke();
    //v·∫Ω nh√£n th·ªùi gian v·ªõi d·∫•u ph·∫©y
    if(Math.abs(tLabel)>1e-8) ctx.fillText(tLabel.toFixed(1).replace(".",","), tx-8, originY+18);
  }

  //V·∫°ch chia tr·ª•c li ƒë·ªô
  const maxCmUp = Math.floor(((canvas.height-80)/2)/pxPerCm -2);
  for(let k=-maxCmUp;k<=maxCmUp;k++){
    const y=originY-k*pxPerCm;
    if(y<10 || y>canvas.height-10) continue;
    ctx.beginPath(); ctx.moveTo(originXvertical-6, y); ctx.lineTo(originXvertical+6,y); ctx.stroke();
    if(k%2===0) ctx.fillText((k).toString().replace(".",","), originXvertical-40, y+4);//ch·ªâ hi·ªÉn th·ªã nh√£n m·ªói 2cm ƒë·ªÉ tr√°nh r·ªëi
  }

  //Nh√£n tr·ª•c
  ctx.fillText('t (s)', canvas.width-30, originY-15);
  ctx.fillText('x (cm)', originXvertical-50, 25);

  //V·∫Ω ƒë∆∞·ªùng sin/cos
  if(history.length<2) return;
  ctx.strokeStyle='#2563eb'; ctx.lineWidth=2; ctx.beginPath();
  let started=false;
  for(let i=0;i<history.length;i++){
    const p = history[i];
    const screenX = originXhorizontal+(p.t-t_offset)*pxPerSec;
    if(screenX<originXhorizontal) continue;
    const screenY = originY-(mToCm(p.x)*pxPerCm);// chuy·ªÉn x_m sang cm r·ªìi sang px
    if(!started){ctx.moveTo(screenX,screenY); started=true;} else ctx.lineTo(screenX,screenY);
  }
  ctx.stroke();

  //Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc m·∫£ng history, ch·ªâ gi·ªØ d·ªØ li·ªáu trong N gi√¢y g·∫ßn nh·∫•t
  const maxPoints=2000;
  if(history.length>maxPoints) history.splice(0,history.length-maxPoints);
}

//V√≤ng l·∫∑p c·∫≠p nh·∫≠t ch√≠nh
function update(){
  if(running && !paused){
    const x = computeX(t);
    history.push({t: t, x: x});
    t_offset += dt;//d·ªùi tr·ª•c th·ªùi gian sang ph·∫£i
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawSimulation(-x);
    drawGraph();
    t+=dt;
  }
  requestAnimationFrame(update);
}
update();

//C√°c n√∫t ƒëi·ªÅu khi·ªÉn
toggleBtn.onclick = () => {
  if(!running){
    running=true; paused=false;
    toggleBtn.textContent="‚è∏ T·∫°m d·ª´ng";
  } else {
    paused=!paused;
    toggleBtn.textContent = paused ? "‚ñ∂ Ti·∫øp t·ª•c" : "‚è∏ T·∫°m d·ª´ng";
  }
};

resetBtn.onclick = () => {
  running=false; paused=false;
  toggleBtn.textContent="‚ñ∂ Ch·∫°y";
  t=0; t_offset=0; history=[];
  window.initializedOffset=undefined;
  const a = computeX(t);
  drawSimulation(-a);
  drawGraph();
};

//C√°c s·ª≠a ƒë·ªïi nh·ªè, ƒë·∫£m b·∫£o reset history khi tham s·ªë thay ƒë·ªïi
[A_slider,A_num,w_slider,w_num,phi_slider,phi_num,func].forEach(el=>{
  el.addEventListener('change',()=>{
    history=[]; t=0; t_offset=0; window.initializedOffset=undefined;
  });
});

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();

  // Gi·ªØ height c·ªë ƒë·ªãnh
  canvas.width = rect.width;
  canvas.height = 300;

  // Reset tr·∫°ng th√°i v·∫Ω
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  // V·∫Ω l·∫°i khung hi·ªán t·∫°i
  history = [];
  t = 0;
  t_offset = 0;
  window.initializedOffset = undefined;

  drawSimulation(0);
  drawGraph();
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas(); // g·ªçi ngay khi load

//V·∫Ω khung ban ƒë·∫ßu
drawSimulation(0);
drawGraph();
</script>
</body>
</html>
