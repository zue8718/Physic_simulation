<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<title>Oscillation Simulator ‚Äî Improved</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  /* Giao di·ªán */
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, sans-serif;
    display: flex;
    height: 100vh;
    background: linear-gradient(135deg, #6EE7B7, #3B82F6);
    color: #fff;
  }
  #sidebar {
    flex: 0 0 auto;
    width: 300px;
    background: rgba(0,0,0,0.25);
    backdrop-filter: blur(10px);
    padding: 20px;
    overflow-y: auto;
    box-sizing: border-box;
  }
  h2 { text-align:center; margin-bottom: 12px; }
  label { font-weight: bold; display:block; margin-top:12px; }
  input[type=range], input[type=number], select {
    width: 100%; padding: 6px; border-radius: 8px; border: none; margin-top:6px; box-sizing:border-box;
  }
  .btns { margin-top:12px; display:flex; gap:6px; }
  button {
    flex:1; padding:10px; border-radius:8px; border:none; cursor:pointer; font-weight:700; background:#ffd54f; color:#000;
  }
  #main { flex:1; padding:20px; display:flex; flex-direction:column; gap:18px; box-sizing:border-box; }
  canvas { 
      width: 100%;
      height: 560px;
      background:#fff; 
      border-radius:10px; 
      border:2px solid #000; 
      display:block; }
  .eqn { margin-top:12px; background: rgba(255,255,255,0.12); padding:8px; border-radius:8px; color:#fff; font-weight:600; }
  .small { font-size:13px; color: #f3f3f3; opacity:0.95; }
</style>
</head>
<body>

<div id="sidebar" >
  <h2>‚öô Th√¥ng s·ªë</h2>

  <label>Bi√™n ƒë·ªô A (cm):</label>
  <input id="A_slider" type="range" min="0" max="10" step="0.1" value="5">
  <input id="A_num" type="number" min="0" max="10" step="0.1" value="5">

  <label>œâ (rad/s):</label>
  <input id="w_slider" type="range" min="0.5" max="20" step="0.1" value="6.28">
  <input id="w_num" type="number" min="0.5" max="20" step="0.1" value="6.28">

  <label>Pha ban ƒë·∫ßu œÜ (rad):</label>
  <input id="phi_slider" type="range" min="-3.14" max="3.14" step="0.01" value="0">
  <input id="phi_num" type="number" min="-3.14" max="3.14" step="0.01" value="0">

  <label>H·ªá s·ªë t·∫Øt d·∫ßn Œ≤ (1/s):</label>
  <input id="beta_slider" type="range" min="0" max="1" step="0.1" value="0.3">
  <input id="beta_num" type="number" min="0" max="1" step="0.1" value="0.3">


  <label>H√†m:</label>
  <select id="func"><option value="cos">cos</option><option value="sin">sin</option></select>

  <div class="btns">
    <button id="toggleBtn">‚ñ∂ Ch·∫°y</button>
    <button id="resetBtn">üîÑ Kh√¥i ph·ª•c</button>
  </div>

  <div class="eqn" id="equation">x(t) = 5.00 cm . cos(6.28 t + 0.00)</div>
  <div class="small">Ph∆∞∆°ng tr√¨nh c·∫≠p nh·∫≠t theo tham s·ªë. ƒê∆°n v·ªã x: cm.</div>
</div>

<div id="main">
  <canvas id="canvas" height="560"></canvas>
</div>

<script>
// Thi·∫øt l·∫≠p tham chi·∫øu ƒë·∫øn c√°c ph·∫ßn t·ª≠ DOM (kh·∫Øc ph·ª•c l·ªìi li√™n k·∫øt)
const A_slider = document.getElementById('A_slider');
const A_num = document.getElementById('A_num');
const w_slider = document.getElementById('w_slider');
const w_num = document.getElementById('w_num');
const phi_slider = document.getElementById('phi_slider');
const phi_num = document.getElementById('phi_num');
const func = document.getElementById('func');
const beta_slider = document.getElementById('beta_slider');
const beta_num = document.getElementById('beta_num');


const toggleBtn = document.getElementById('toggleBtn');
const resetBtn = document.getElementById('resetBtn');
const equationDiv = document.getElementById('equation');

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Tr·∫°ng th√°i
let A_cm = parseFloat(A_num.value);
let omega = parseFloat(w_num.value);
let phi = parseFloat(phi_num.value);
let mode = func.value;
let beta = parseFloat(beta_num.value);


let t = 0;
let dt = 0.02;
let running = false;
let paused = false;
let history = [];
let t_offset = 0; //slide for timeline

// H√†m h·ªó tr·ª£ chuy·ªÉn ƒë·ªïi ƒë∆°n v·ªã
function cmToM(cm){ return cm/100; }
function mToCm(m){ return m*100; }

// Li√™n k·∫øt d·ªØ li·ªáu gi·ªØa slider v√† √¥ nh·∫≠p m·ªôt c√°ch ·ªïn ƒë·ªãnh
function bind(sliderEl, numEl, onChange) {
  sliderEl.addEventListener('input', () => { numEl.value = sliderEl.value; onChange(); });
  numEl.addEventListener('input', () => {
    // √âp gi√° tr·ªã v√†o trong kho·∫£ng min/max gi·ªëng nh∆∞ slider
    if(numEl.value==='') return;
    let v = parseFloat(numEl.value);
    if(v<parseFloat(sliderEl.min)) v=parseFloat(sliderEl.min);
    if(v>parseFloat(sliderEl.max)) v=parseFloat(sliderEl.max);
    sliderEl.value = v;
    onChange();
  });
}

bind(A_slider,A_num,()=>{ A_cm = parseFloat(A_num.value); updateEquation(); });
bind(w_slider,w_num,()=>{ omega = parseFloat(w_num.value); updateEquation(); });
bind(phi_slider,phi_num,()=>{ phi = parseFloat(phi_num.value); updateEquation(); });
bind(beta_slider, beta_num, ()=>{ beta = parseFloat(beta_num.value); updateEquation(); });

func.addEventListener('change', ()=>{ mode = func.value; updateEquation(); });

// Hi·ªÉn th·ªã ph∆∞∆°ng tr√¨nh
function updateEquation(){
  // Hi·ªÉn th·ªã cos/sin v√† in gi√° tr·ªã v·ªõi 2 ch·ªØ s·ªë th·∫≠p ph√¢n
  const Ashow = Number(A_cm).toFixed(1).replace(".",",");
  const wshow = Number(omega).toFixed(2).replace(".",",");
  const phishow = Math.abs(phi).toFixed(2).replace(".",",");
  const fun = (mode==='cos')?'cos':'sin';
  const betashow = Number(beta).toFixed(2).replace(".",",");
  
  let phiStr = '';
  if (phi >= 0) {
    phiStr = ` + ${phishow}`;
  } else if (phi < 0) {
    phiStr = ` ‚àí ${phishow}`;
    }
    
equationDiv.innerHTML =
  `x(t) = ${Ashow}.e<sup>-${betashow}t</sup>.${fun}(${wshow}t ${phiStr}) (cm)`;
}

// Kh·ªüi t·∫°o
updateEquation();

// T√≠nh x(t) v√† tr·∫£ v·ªÅ ƒë∆°n v·ªã m ‚Äî DAO ƒê·ªòNG T·∫ÆT D·∫¶N
function computeX(tval){
  const A_m = cmToM(A_cm);
  const arg = omega * tval + phi;
  const decay = Math.exp(-beta * tval);   // h·ªá s·ªë t·∫Øt d·∫ßn
  return (mode === 'cos')
    ? A_m * decay * Math.cos(arg)
    : A_m * decay * Math.sin(arg);
}

//V·∫Ω m√¥ ph·ªèng (l√≤ xo v√† v·∫≠t n·∫∑ng)
function drawSimulation(x_m){
  // x_m t√≠nh b·∫±ng m, chuy·ªÉn sang px ƒë·ªÉ hi·ªÉn th·ªã, cƒÉn gi·ªØa theo chi·ªÅu ngang
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  const scale = (canvas.height-80)/24*100; //px tr√™n m, cho gi·∫£ l·∫≠p h√¨nh ·∫£nh, d√πng ƒë·ªÉ tƒÉng gi·∫£m ƒë·ªô d√†i

  // ƒêi·ªÉm c·ªë ƒë·ªãnh c·ªßa l√≤ xo
  const anchorX = centerX;
  const anchorY = 30;
  
  // V·∫Ω t∆∞·ªùng c·ªë ƒë·ªãnh
  ctx.fillStyle='#444';
  ctx.fillRect(anchorX-40,anchorY,80,10);

  // L√≤ xo: v·∫Ω d·∫°ng rƒÉng c∆∞a t·ª´ ƒëi·ªÉm c·ªë ƒë·ªãnh ƒë·∫øn t√¢m v·∫≠t n·∫∑ng
  const massX = centerX;
  const massY = centerY + x_m*scale;
  const springEndY = massY - 15; //ƒêi·ªÉm g·∫Øn v√†o v·∫≠t n·∫∑ng

  //V·∫Ω ƒë∆∞·ªùng l√≤ xo
  ctx.strokeStyle='#222';
  ctx.lineWidth=3;
  ctx.beginPath();
  const coils=10;
  const totalLen = Math.max(30, springEndY - anchorY -15);
  const step = totalLen/(coils*2);
  let px=anchorX, py=anchorY;
  ctx.moveTo(px, py+10);
  for(let i=0;i<coils*2;i++){
    py += step;
    px = anchorX + (i%2===0?-15:15); //tƒÉng m·ª©c ƒë·ªô gi√£n cho l√≤ xo
    ctx.lineTo(px, py+10);
  }
  ctx.lineTo(anchorX, springEndY);
  ctx.stroke();

  //Th√¥ng s·ªë v·∫≠t n·∫∑ng
  const wRect =36, hRect=28;
  const rectX = massX - wRect/2;
  const rectY = massY - hRect/2;
  //ƒê·ªï b√≥ng
  ctx.fillStyle='rgba(0,0,0,0.12)';
  ctx.fillRect(rectX+6, rectY+10, wRect,6);
  //Kh·ªëi ch√≠nh c·ªßa v·∫≠t n·∫∑ng
  ctx.fillStyle='#ff3b7f';
  ctx.fillRect(rectX, rectY, wRect, hRect);
  ctx.strokeStyle='#b3164f';
  ctx.lineWidth=2;
  ctx.strokeRect(rectX, rectY, wRect, hRect);
  //V·ªát s√°ng nh·ªè
  ctx.fillStyle='rgba(255,255,255,0.6)';
  ctx.fillRect(rectX+4, rectY+4, Math.max(4,wRect/3),6);
}

// V·∫Ω ƒë·ªì th·ªã
function drawGraph(){

  //B·ªë c·ª•c v√† t·ªâ l·ªá
  const originXhorizontal = 20;//l·ªÅ tr√°i tr·ª•c ngang
  const originXvertical = canvas.width/2;//l·ªÅ tr√°i tr·ª•c d·ªçc
  const originY = canvas.height/2;//cƒÉn gi·ªØa theo chi·ªÅu d·ªçc
  const pxPerSec = 80; //t·ªâ l·ªá ngang (px tr√™n s)
  const pxPerCm = (canvas.height-80)/24; //t·ªâ l·ªá d·ªçc (px tr√™n cm)

  //V·∫Ω l∆∞·ªõi m·ªù
  ctx.strokeStyle='#e6e6e6';
  ctx.lineWidth=0.6;
  for(let gx=0;gx<canvas.width;gx+=50){ctx.beginPath();ctx.moveTo(gx,0);ctx.lineTo(gx,canvas.height/2);ctx.stroke();}
  for(let gy=0;gy<canvas.height/2;gy+=54){ctx.beginPath();ctx.moveTo(0,gy);ctx.lineTo(canvas.width,gy);ctx.stroke();}

  //Tr·ª•c to·∫°n ƒë·ªô
  ctx.strokeStyle='#000';
  ctx.lineWidth=2;
  //Tr·ª•c ƒë·ª©ng
  ctx.beginPath(); ctx.moveTo(originXvertical,10); ctx.lineTo(originXvertical,canvas.height-10); ctx.stroke();
  //Tr·ª•c ngang
  ctx.beginPath(); ctx.moveTo(originXhorizontal,originY); ctx.lineTo(canvas.width-20,originY); ctx.stroke();

  //M≈©i t√™n tr·ª•c
  ctx.fillStyle='#000';
  //d·ªçc
  ctx.beginPath(); ctx.moveTo(originXvertical,10); ctx.lineTo(originXvertical-6,22); ctx.lineTo(originXvertical+6,22); ctx.closePath(); ctx.fill();
  //ngang
  ctx.beginPath(); ctx.moveTo(canvas.width-10,originY); ctx.lineTo(canvas.width-20,originY-6); ctx.lineTo(canvas.width-20,originY+6); ctx.closePath(); ctx.fill();
  
  //V·∫°ch chia tr√™n tr·ª•c th·ªùi gian
  ctx.fillStyle='#000';
  ctx.font='13px Arial';
  const tickSec=0.5, marginRight=20;
  const totalVisibleTime = (canvas.width-originXhorizontal-marginRight)/pxPerSec; //T√≠nh s·ªë tick c·∫ßn hi·ªÉn th·ªã d·ª±a tr√™n ƒë·ªô r·ªông canvas
  if(typeof window.initializedOffset==="undefined"){ t_offset=-totalVisibleTime/2; window.initializedOffset=true; }
  const firstTick = Math.floor(t_offset/tickSec);
  const lastTick = Math.ceil((t_offset+totalVisibleTime-0.5)/tickSec);

  for(let i=firstTick;i<=lastTick;i++){
    const tLabel=i*tickSec;
    const tx = originXhorizontal+(tLabel-t_offset)*pxPerSec;
    if(tLabel<0 || tx<originXhorizontal) continue; //ch·ªâ v·∫Ω tr√™n canvas
    //v·∫Ω tick nh·ªè
    ctx.beginPath(); ctx.moveTo(tx, originY-6); ctx.lineTo(tx, originY+6); ctx.stroke();
    //v·∫Ω nh√£n th·ªùi gian v·ªõi d·∫•u ph·∫©y
    if(Math.abs(tLabel)>1e-8) ctx.fillText(tLabel.toFixed(1).replace(".",","), tx-8, originY+18);
  }

  //V·∫°ch chia tr·ª•c li ƒë·ªô
  const maxCmUp = Math.floor(((canvas.height-80)/2)/pxPerCm -2);
  for(let k=-maxCmUp;k<=maxCmUp;k++){
    const y=originY-k*pxPerCm;
    if(y<10 || y>canvas.height-10) continue;
    ctx.beginPath(); ctx.moveTo(originXvertical-6, y); ctx.lineTo(originXvertical+6,y); ctx.stroke();
    if(k%2===0) ctx.fillText((k).toString().replace(".",","), originXvertical-40, y+4);//ch·ªâ hi·ªÉn th·ªã nh√£n m·ªói 2cm ƒë·ªÉ tr√°nh r·ªëi
  }

  //Nh√£n tr·ª•c
  ctx.fillText('t (s)', canvas.width-30, originY-15);
  ctx.fillText('x (cm)', originXvertical-50, 25);

  // ===== ƒê∆Ø·ªúNG BI√äN ƒê·ªò BAN ƒê·∫¶U ¬±A =====
  const A_px = A_cm * pxPerCm;

  ctx.save();
  ctx.setLineDash([8, 6]); // n√©t ƒë·ª©t
  ctx.strokeStyle = '#dc2626'; // ƒë·ªè
  ctx.lineWidth = 1.5;

  // +A
  ctx.beginPath();
  ctx.moveTo(originXhorizontal, originY - A_px);
  ctx.lineTo(canvas.width - 20, originY - A_px);
  ctx.stroke();

  // -A
  ctx.beginPath();
  ctx.moveTo(originXhorizontal, originY + A_px);
  ctx.lineTo(canvas.width - 20, originY + A_px);
  ctx.stroke();

  ctx.restore();

  //V·∫Ω ƒë∆∞·ªùng sin/cos
  if(history.length<2) return;
  ctx.strokeStyle='#2563eb'; ctx.lineWidth=2; ctx.beginPath();
  let started=false;
  for(let i=0;i<history.length;i++){
    const p = history[i];
    const screenX = originXhorizontal+(p.t-t_offset)*pxPerSec;
    if(screenX<originXhorizontal) continue;
    const screenY = originY-(mToCm(p.x)*pxPerCm);// chuy·ªÉn x_m sang cm r·ªìi sang px
    if(!started){ctx.moveTo(screenX,screenY); started=true;} else ctx.lineTo(screenX,screenY);
  }
  ctx.stroke();

  //Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc m·∫£ng history, ch·ªâ gi·ªØ d·ªØ li·ªáu trong N gi√¢y g·∫ßn nh·∫•t
  const maxPoints=2000;
  if(history.length>maxPoints) history.splice(0,history.length-maxPoints);
}

//V√≤ng l·∫∑p c·∫≠p nh·∫≠t ch√≠nh
function update(){
  if(running && !paused){
    const x = computeX(t);
    history.push({t: t, x: x});
    t_offset += dt;//d·ªùi tr·ª•c th·ªùi gian sang ph·∫£i
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawSimulation(-x);
    drawGraph();
    t+=dt;
  }
  requestAnimationFrame(update);
}
update();

//C√°c n√∫t ƒëi·ªÅu khi·ªÉn
toggleBtn.onclick = () => {
  if(!running){
    running=true; paused=false;
    toggleBtn.textContent="‚è∏ T·∫°m d·ª´ng";
  } else {
    paused=!paused;
    toggleBtn.textContent = paused ? "‚ñ∂ Ti·∫øp t·ª•c" : "‚è∏ T·∫°m d·ª´ng";
  }
};

resetBtn.onclick = () => {
  running=false; paused=false;
  toggleBtn.textContent="‚ñ∂ Ch·∫°y";
  t=0; t_offset=0; history=[];
  window.initializedOffset=undefined;
  const a = computeX(t);
  drawSimulation(-a);
  drawGraph();
};

//C√°c s·ª≠a ƒë·ªïi nh·ªè, ƒë·∫£m b·∫£o reset history khi tham s·ªë thay ƒë·ªïi
[A_slider,A_num,w_slider,w_num,phi_slider,phi_num,func,beta_slider,beta_num].forEach(el=>{
  el.addEventListener('change',()=>{
    history=[]; t=0; t_offset=0; window.initializedOffset=undefined;
  });
});

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width;   // width theo tr√¨nh duy·ªát
  canvas.height = 560;         // gi·ªØ nguy√™n height
  
  // Reset tr·∫°ng th√°i v·∫Ω
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  // V·∫Ω l·∫°i khung hi·ªán t·∫°i
  history = [];
  t = 0;
  t_offset = 0;
  window.initializedOffset = undefined;

  drawSimulation(0);
  drawGraph();
}

window.addEventListener('resize', () => {
  resizeCanvas();
});

resizeCanvas();
//V·∫Ω khung ban ƒë·∫ßu
drawSimulation(0);
drawGraph();
</script>
</body>
</html>
