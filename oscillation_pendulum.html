<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<title>Pendulum Simulator ‚Äî Con l·∫Øc ƒë∆°n</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  /* Giao di·ªán */
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, sans-serif;
    display: flex;
    height: 100vh;
    background: linear-gradient(135deg, #6EE7B7, #3B82F6);
    color: #fff;
  }
  #sidebar {
    flex:0 0 auto;
    width: 340px;
    background: rgba(0,0,0,0.25);
    backdrop-filter: blur(10px);
    padding: 20px;
    overflow-y: auto;
    box-sizing: border-box;
  }
  h2 { text-align:center; margin-bottom: 12px; }
  label { font-weight: bold; display:block; margin-top:12px; }
  input[type=range], input[type=number], select {
    width: 100%; padding: 6px; border-radius: 8px; border: none; margin-top:6px; box-sizing:border-box;
  }
  .btns { margin-top:12px; display:flex; gap:6px; }
  button {
    flex:1; padding:10px; border-radius:8px; border:none; cursor:pointer; font-weight:700; background:#ffd54f; color:#000;
  }
  #main { flex:1; padding:20px; display:flex; flex-direction:column; gap:18px; box-sizing:border-box; }
  canvas { 
      width: 100%;
      height: 560px;
      background:#fff; 
      border-radius:10px; 
      border:2px solid #000; 
      display:block; }
  .eqn { margin-top:12px; background: rgba(255,255,255,0.12); padding:8px; border-radius:8px; color:#fff; font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .small { font-size:13px; color: #f3f3f3; opacity:0.95; }
  .row { display:flex; gap:8px; align-items:center; }
  .muted { font-size:12px; opacity:0.9; color:#f3f3f3; }
</style>
</head>
<body>

<div id="sidebar">
  <h2>‚öô Con l·∫Øc ƒë∆°n</h2>

  <label>Bi√™n ƒë·ªô g√≥c Œ∏‚ÇÄ (rad):</label>
  <input id="A_slider" type="range" min="0" max="0.7" step="0.01" value="0.20">
  <input id="A_num" type="number" min="0" max="0.7" step="0.01" value="0.20">

  <label>Chi·ªÅu d√†i d√¢y L (m):</label>
  <input id="L_slider" type="range" min="0.1" max="1.5" step="0.01" value="1.00">
  <input id="L_num" type="number" min="0.1" max="1.5" step="0.01" value="1.00">

  <label>œâ (rad/s) ‚Äî t√≠nh t·ª´ g/L:</label>
  <div class="row">
    <input id="w_display" type="number" step="0.01" value="0" style="flex:1;" readonly>
    <div class="muted" style="width:60px;text-align:right;">g=9,81</div>
  </div>

  <label>Pha ban ƒë·∫ßu œÜ (rad):</label>
  <input id="phi_slider" type="range" min="-3.14" max="3.14" step="0.01" value="0">
  <input id="phi_num" type="number" min="-3.14" max="3.14" step="0.01" value="0">

  <label>H√†m:</label>
  <select id="func"><option value="cos">cos</option><option value="sin">sin</option></select>

  <label>T·ªëc ƒë·ªô m√¥ ph·ªèng:</label>
  <select id="speed">
    <option value="1">1√ó (m·∫∑c ƒë·ªãnh)</option>
    <option value="0.5">0.5√ó</option>
    <option value="0.25">0.25√ó</option>
  </select>
  
  <div class="btns">
    <button id="toggleBtn">‚ñ∂ Ch·∫°y</button>
    <button id="resetBtn">üîÑ Kh√¥i ph·ª•c</button>
  </div>

  <div class="eqn" id="equation">Œ∏(t) = 0,20 . cos(œÄ t + 0.00) (rad)</div>
  <div class="small">Ph∆∞∆°ng tr√¨nh: Œ∏(t) = Œ∏‚ÇÄ . cos(œâ t + œÜ)</div>
</div>

<div id="main">
  <canvas id="canvas" height="560"></canvas>
</div>

<script>
/* DOM */
const A_slider = document.getElementById('A_slider');
const A_num = document.getElementById('A_num');
const L_slider = document.getElementById('L_slider');
const L_num = document.getElementById('L_num');
const w_display = document.getElementById('w_display');
const phi_slider = document.getElementById('phi_slider');
const phi_num = document.getElementById('phi_num');
const func = document.getElementById('func');
const speedSel = document.getElementById('speed');

const toggleBtn = document.getElementById('toggleBtn');
const resetBtn = document.getElementById('resetBtn');
const equationDiv = document.getElementById('equation');

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

/* H·∫±ng s·ªë */
const g = 9.81; // m/s^2

/* Tr·∫°ng th√°i */
let theta0 = parseFloat(A_num.value); // rad
let L = parseFloat(L_num.value); // m
let omega = Math.sqrt(g / L);
let phi = parseFloat(phi_num.value);
let mode = func.value;

let t = 0;
let dt = 0.02;
let running = false;
let paused = false;
let history = []; // l∆∞u {t, x} v·ªõi x (m)
let t_offset = 0;
let pxPerMeter = 250; // scale hi·ªÉn th·ªã cho con l·∫Øc (px/m)
let simSpeed = 1; //T·ªëc ƒë·ªô m√¥ ph·ªèng (1x, 0.5x, 0.25x)

/* Helpers */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function mToCm(m){ return m*100; }

/* Bind helpers */
function bind(sliderEl, numEl, onChange) {
  sliderEl.addEventListener('input', () => {
    numEl.value = sliderEl.value;
    onChange();
  });
  numEl.addEventListener('input', () => {
    if(numEl.value === '') return;
    let v = parseFloat(numEl.value);
    if (v < parseFloat(sliderEl.min)) v = parseFloat(sliderEl.min);
    if (v > parseFloat(sliderEl.max)) v = parseFloat(sliderEl.max);
    sliderEl.value = v;
    onChange();
  });
}

/* C·∫≠p nh·∫≠t hi·ªÉn th·ªã œâ v√† ph∆∞∆°ng tr√¨nh */
function updateOmegaFromL(){
  omega = Math.sqrt(g / L);
  w_display.value = omega.toFixed(3);
}
function updateEquation(){
  const th = Number(theta0).toFixed(2).replace(".",",");
  const wsh = Number(omega).toFixed(2).replace(".",",");
  const ph = Math.abs(phi).toFixed(2).replace(".",",");
  const fun = (mode === 'cos') ? 'cos' : 'sin';
  
  let phiStr = '';
  if (phi >= 0) {
    phiStr = ` + ${ph}`;
  } else if (phi < 0) {
    phiStr = ` ‚àí ${ph}`;
    }

  equationDiv.textContent = `x(t) = ${th} . ${fun}(${wsh} t${phiStr}) (cm)`;
}

/* Kh·ªüi t·∫°o li√™n k·∫øt */
bind(A_slider, A_num, ()=>{
  theta0 = parseFloat(A_num.value);
  history = []; t = 0; t_offset = 0; window.initializedOffset = undefined;
  updateEquation();
});
bind(L_slider, L_num, ()=>{
  L = parseFloat(L_num.value);
  updateOmegaFromL();
  history = []; t = 0; t_offset = 0; window.initializedOffset = undefined;
  updateEquation();
});
bind(phi_slider, phi_num, ()=>{
  phi = parseFloat(phi_num.value);
  history = []; t = 0; t_offset = 0; window.initializedOffset = undefined;
  updateEquation();
});
func.addEventListener('change', ()=> { mode = func.value; history = []; t = 0; t_offset = 0; window.initializedOffset = undefined; updateEquation(); });

updateOmegaFromL();
updateEquation();

/* Li√™n k·∫øt t·ªëc ƒë·ªô m√¥ ph·ªèng */
speedSel.addEventListener('change', () => {
  simSpeed = parseFloat(speedSel.value);
});

/* T√≠nh tr·∫°ng th√°i con l·∫Øc t·∫°i th·ªùi ƒëi·ªÉm t (tr·∫£ v·ªÅ theta (rad), x (m), y (m)) */
function computePendulum(tval){
  const arg = omega * tval + phi;
  const theta = (mode === 'cos') ? theta0 * Math.cos(arg) : theta0 * Math.sin(arg);
  const x = L * theta;
  const y = L * Math.cos(theta);
  return {theta, x, y};
}

/* V·∫Ω con l·∫Øc ƒë∆°n */
function drawSimulation(state){
  // state: {theta,x,y} v·ªõi x,y (m)
  ctx.clearRect(0,0,canvas.width, canvas.height);

  // Layout: ph√≠a tr√™n canvas l√† con l·∫Øc, ph√≠a d∆∞·ªõi l√† ...
  const padding = 20;
  const topHeight = Math.min(260, canvas.height * 0.45);
  const originX = canvas.width / 2;
  const originY = padding + 20;

  // T·ªâ l·ªá hi·ªÉn th·ªã d·ª±a tr√™n pxPerMeter
  const scale = pxPerMeter;

  // V·ªã tr√≠ qu·∫£ c·∫ßu
  const bobX = originX + state.x * scale;
  const bobY = originY + state.y * scale;

  // N·ªÅn nh·∫π cho v√πng con l·∫Øc
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  ctx.fillRect(0, 0, canvas.width, topHeight);

  // V·∫Ω m·ªëc treo
  ctx.fillStyle = '#222';
  ctx.fillRect(originX-28, originY-8, 56, 12);

  // V·∫Ω d√¢y
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(originX, originY);
  ctx.lineTo(bobX, bobY);
  ctx.stroke();

  // V·∫Ω d√¢y m·ªÅm (n√©t m·∫£nh)
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(originX+6, originY);
  ctx.lineTo(bobX+4, bobY);
  ctx.stroke();

  // V·∫Ω qu·∫£ c·∫ßu (bob)
  const bobR = Math.max(10, Math.min(26, 0.04 * scale)); // b√°n k√≠nh t√πy scale
  ctx.fillStyle = '#ff3b7f';
  ctx.beginPath();
  ctx.arc(bobX, bobY, bobR, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = '#b3164f';
  ctx.lineWidth = 2;
  ctx.stroke();

  // V·ªát s√°ng
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fillRect(bobX - bobR/2 + 4, bobY - bobR/2 + 4, Math.max(4, bobR/2), 6);
  
  //T·ªça ƒë·ªô h√¨nh chi·∫øu
  const proX = bobX;
  const proY = 350;
  
  //V·∫Ω ƒë∆∞·ªùng gi√≥ng t·ª´ con l·∫Øc ƒë·∫øn h√¨nh chi·∫øu
  ctx.strokeStyle = "rgba(0,0,0,0.4)";
  ctx.beginPath();
  ctx.moveTo(bobX, bobY);      // t·ª´ con l·∫Øc
  ctx.lineTo(proX, proY); // ƒë·∫øn h√¨nh chi·∫øu
  ctx.stroke();

}

/* --- V·∫º CHUY·ªÇN ƒê·ªòNG TR√íN ƒê·ªÄU --- */
function drawCircularMotion(tval){
  const R = L * theta0;         // b√°n k√≠nh h√¨nh tr√≤n tham chi·∫øu (m)
  const scale = pxPerMeter;     // px/m

  const originX = canvas.width /2;          // v·ªã tr√≠ v·∫Ω h√¨nh tr√≤n (tr√°i canvas)
  const originY = 350;

  const angle = omega * tval + phi;

  // T·ªça ƒë·ªô ƒëi·ªÉm P tr√™n ƒë∆∞·ªùng tr√≤n
  let xc, yc;
  if (mode === "cos") {
      xc = R * Math.cos(angle);
      yc = R * Math.sin(angle);}
    else {
        xc = R * Math.sin(angle);
        yc = -R * Math.cos(angle);
    }

  const Px = originX + xc * scale;
  const Py = originY + yc * scale;

  // V·∫Ω ƒë∆∞·ªùng tr√≤n
  ctx.strokeStyle = "#222";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(originX, originY, R * scale, 0, Math.PI * 2);
  ctx.stroke();

  // V·∫Ω tr·ª•c ngang
  ctx.strokeStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.moveTo(originX - R*scale - 20, originY);
  ctx.lineTo(originX + R*scale + 20, originY);
  ctx.stroke();

  // V·∫Ω ƒëi·ªÉm P (ƒë·ªè)
  ctx.fillStyle = "#ff3b7f";
  ctx.beginPath();
  ctx.arc(Px, Py, 8, 0, Math.PI * 2);
  ctx.fill();

  // V·∫Ω h√¨nh chi·∫øu P xu·ªëng tr·ª•c ngang
  const projX = Px;
  const projY = originY;

  ctx.strokeStyle = "rgba(0,0,0,0.4)";
  ctx.beginPath();
  ctx.moveTo(Px, Py);
  ctx.lineTo(projX, projY);
  ctx.stroke();

  ctx.fillStyle = "#ffa600";
  ctx.beginPath();
  ctx.arc(projX, projY, 6, 0, Math.PI * 2);
  ctx.fill();
}

// V√≤ng l·∫∑p ch√≠nh
function update(){
  if (running && !paused){
    const state = computePendulum(t); // state.x (m)
    history.push({t: t, x: state.x});
    t_offset += dt;
    ctx.clearRect(0,0,canvas.width, canvas.height);
    drawSimulation(state);
    drawCircularMotion(t);
    t += dt * simSpeed;
  }
  requestAnimationFrame(update);
}
update();

// ƒêi·ªÅu khi·ªÉn
toggleBtn.onclick = () => {
    if (!running) {
    running = true; paused=false;
    toggleBtn.textContent="‚è∏ T·∫°m d·ª´ng";
  } else {
    paused=!paused;
    toggleBtn.textContent = paused ? "‚ñ∂ Ti·∫øp t·ª•c" : "‚è∏ T·∫°m d·ª´ng";
  }
};
    
resetBtn.onclick = () => {
  running = false;paused=false;
  toggleBtn.textContent="‚ñ∂ Ch·∫°y"
  t = 0;  t_offset = 0;  history = [];
  window.initializedOffset = undefined;
  ctx.clearRect(0,0,canvas.width, canvas.height);
  drawSimulation(computePendulum(0));
  drawCircularMotion(0);
};

// C√°c s·ª≠a ƒë·ªïi ƒë·∫£m b·∫£o reset history khi tham s·ªë thay ƒë·ªïi
[A_slider, A_num, L_slider, L_num, phi_slider, phi_num, func].forEach(el=>{
  el.addEventListener('change', ()=> {
    history = [];
    t = 0;
    t_offset = 0;
    window.initializedOffset = undefined;
  });
});

function resizeCanvas() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width;   // width theo tr√¨nh duy·ªát
  canvas.height = 560;         // gi·ªØ nguy√™n height
}

window.addEventListener('resize', () => {
  resizeCanvas();
  drawSimulation(computePendulum(t));
  drawCircularMotion(t);
});

resizeCanvas();

// V·∫Ω ban ƒë·∫ßu
let initialState = computePendulum(0);
drawSimulation(initialState);
drawCircularMotion(0);

</script>
</body>
</html>
